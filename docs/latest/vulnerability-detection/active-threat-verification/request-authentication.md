# Authenticating Replayed Attacks <a href="../../../about-wallarm/subscription-plans/#subscription-plans"><img src="../../../images/api-security-tag.svg" style="border: none;"></a>

Wallarm employs a unique approach to detect security vulnerabilities known as [**Active Threat Verification**](overview.md) which transforms attackers into penetration testers. After analyzing an attacker's request, it crafts and tests potential vulnerability‑exposing requests on your application. Given that your endpoints may need authentication, this article shows how to do it securely.

## Default removal of standard authentication headers

By default, the standard authentication headers `Cookie`, `Authorization: Basic`, and `Viewstate` are automatically omitted when replaying attacks, ensuring the tests are safe.

In rare cases, Wallarm might wrongly label a legitimate request as malicious. Replaying this request without removing its authentication data, particularly it is not idempotent, can cause issues. For instance, if a request is meant to create an item and it is replayed several times, the client's account might get filled with unwanted repeat items.

## Handling non‑standard authentication data

If your application uses non‑standard types of authentication (for example, request string token or custom HTTP request header or JSON attribute in POST body), you can mask this data preventing it from being used in simulated attacks.

Set up a [data masking rule](../../user-guides/rules/sensitive-data-rule.md) to ensure that filtering nodes do not forward this information to Wallarm Cloud. This way, the **Active Threat Verification** requests will exclude this data, preventing unauthorized actions that might harm the system.

## Providing authentication data for the module

If the original request included authentication details, the **Active Threat Verification** module, based on default settings and masking rules, will strip them and replay the attack without them. If authentication is needed to access the application's API, a `401` error or a similar response might be returned. This does not indicate vulnerability, and thus, Wallarm might miss an active vulnerability.

To avoid this, consider generating dedicated authentication parameters for this verification process if this authentication data is passed in the headers of requests. By controlling the access linked to these parameters, you ensure a more secure attack replay process.

To furnish the replayed requests with necessary authentication details:

1. Proceed to Wallarm Console → **Rules** → create the rule **Rewrite attack before active verification**.
1. Fill in the rule creation form following the instructions:

    * **Condition** [describes](../../user-guides/rules/add-rule.md#branch-description) the endpoints to apply the rule to.
    * **Rules** sets the new value for the parameter selected in the **Part of request** field. A set value will be used when replaying the attack.

        The value must be decoded and set using the [template language Liquid](https://shopify.github.io/liquid/) as follows: placed in double curly braces `{{}}` and single quotes `''`. For example: `{{'example.com'}}`.

    * **Part of request** points to the original request element that should be modified before replaying the attack.

    !!! warning "Possible values of the field **Part of request**"
        Possible values of the **Part of request** field are `header` (request header). Other request elements cannot be modified or added.

1. Wait for the [rule compilation to complete](../../user-guides/rules/compiling.md).

For instance, to ensure attacks replayed on `example.com` carry the value `PHPSESSID=mntdtbgt87j3auaq60iori2i63; security=low` in the `COOKIE` header:

![!Example of the rule modifying COOKIE](../../images/user-guides/rules/rewrite-request-example-cookie.png)

The format of the header value is `{{'PHPSESSID=mntdtbgt87j3auaq60iori2i63; security=low'}}`.
