[al-brute-force-attack]:      ../../attacks-vulns-list.md#bruteforce-attack
[al-forced-browsing]:         ../../attacks-vulns-list.md#forced-browsing

# Overview of Active Threat Verification <a href="../../../about-wallarm/subscription-plans/#subscription-plans"><img src="../../../images/api-security-tag.svg" style="border: none;"></a>

Wallarm's Active Threat Verification turns attackers into your own penetration testers. It analyzes initial attack attempts, then explores other ways the same attack could be exploited. This exposes weak spots in your non-production environment that even the original attackers did not find.

The Active Threat Verification capabilities:

* **Real-time testing**: Uses live attack data to spot current and potential future weak spots, keeping you one step ahead of hackers.
* **Safe non-production tests**: Runs vulnerability checks in a staging or development setup using real production data, but without the risks like system overload or data exposure.
* **Safe & smart simulation**: Skips sensitive authentication details and removes harmful code in tests. Simulates attack techniques for max security, not risking actual harm.

## Enabling the module

The module is disabled by default. To ensure secure Active Threat Verification, follow these steps:

1. Enable Active Threat Verification.
1. Configure a non-production environment host.
1. Configure a non-production authentication cookie or API key.

[Guide on secure Active Threat Verification configuration](enable-disable-active-threat-verification.md)

This module is available under the **Advanced API Security** [subscription](../../about-wallarm/subscription-plans.md#subscription-plans) only. 

## How it works

The Active Threat Verification module operates on the Wallarm Cloud. It generates approximately 100-150 test requests for your non-production environment based on real detected attack data. The requests are with various malicious payloads aimed at the detected vulnerability. These tests simulate attacks without using real malicious syntax, ensuring your resources remain unharmed.

By analyzing responses in the non-production environment, the module determines vulnerability to specific [attack types](../../attacks-vulns-list.md). Discovered vulnerabilities are cataloged in the Wallarm Console UI's **Vulnerabilities** section. Additionally, you have the option to receive [notifications](../../user-guides/settings/integrations/integrations-intro.md) about these findings.

The following scheme demonstrates how the module works:

![ATV scheme](../../images/vulnerability-detection/active-threat-verification-scheme.png)

The generated requests carry the `User-Agent: Wallarm Threat-Verification (v1.x)` header, helping differentiate them from other requests.

Authentication headers like `Cookie`, `Authorization: Basic`, and `Viewstate` are excluded from replayed requests. Further, as guided by the [custom authentication headers](enable-disable-active-threat-verification.md#3-configure-a-non-production-authentication-cookie-or-api-key) and [masking rule](enable-disable-active-threat-verification.md#masking-sensitive-data), any additional headers may be adapted or removed as required.

**Example**

Consider the following real-world-like GET request:

```bash
https://example.com/login?token=IyEvYmluL3NoCg&user=UNION SELECT username, password
```

From the request, the module learns the following details:

* The attacked URL is `https://example.com/login`
* The type of used attack is SQLi (according to the `UNION SELECT username, password` payload)
* The attacked query string parameter is `user`
* Additional piece of information provided in the request is the request string parameter `token=IyEvYmluL3NoCg` (it is probably used by the application to authenticate the user)

Leveraging this data, the module crafts a series of test requests. These requests focus on potential SQL injection vulnerabilities using varied payloads, such as:

```bash
https://example-test.env.srv.loc/login?token=IyEvYmluL3NoCg&user=1')+WAITFOR+DELAY+'0 indexpt'+AND+('wlrm'='wlrm
https://example-test.env.srv.loc/login?token=IyEvYmluL3NoCg&user=1+AND+SLEEP(10)--+wlrm
https://example-test.env.srv.loc/login?token=IyEvYmluL3NoCg&user=1);SELECT+PG_SLEEP(10)--
https://example-test.env.srv.loc/login?token=IyEvYmluL3NoCg&user=1'+OR+SLEEP(10)+AND+'wlrm'='wlrm
https://example-test.env.srv.loc/login?token=IyEvYmluL3NoCg&user=1+AND+1=(SELECT+1+FROM+PG_SLEEP(10))
https://example-test.env.srv.loc/login?token=IyEvYmluL3NoCg&user=%23'%23\x22%0a-sleep(10)%23
https://example-test.env.srv.loc/login?token=IyEvYmluL3NoCg&user=1';+WAITFOR+DELAY+'0code:10'--
https://example-test.env.srv.loc/login?token=IyEvYmluL3NoCg&user=1%27%29+OR+SLEEP%280%29+AND+%28%27wlrm%27%3D%27wlrm
https://example-test.env.srv.loc/login?token=IyEvYmluL3NoCg&user=SLEEP(10)/*'XOR(SLEEP(10))OR'|\x22XOR(SLEEP(10))OR\x22*/
```

## Limitations

Active threat verification is unavailable for [attacks that consist of hits grouped by originating IPs](../../user-guides/triggers/trigger-examples.md#group-hits-originating-from-the-same-ip-into-one-attack).
