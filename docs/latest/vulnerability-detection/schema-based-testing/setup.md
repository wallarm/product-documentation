# Schema-Based Testing Setup

This article describes how to enable and configure Wallarm's [Schema-Based Testing](overview.md).

## Enable

Schema-Based Testing is disabled by default. To enable:

1. If in Wallarm Console you do not see the **Security Testing** → **Schema-Based** section, contact the [Wallarm support team](https://support.wallarm.com/) to enable.
1. Go to the **Security Testing** → **Schema-Based** → **Test policies** tab and create [at least one policy](#configure-test-policies).

## Prerequisites - token

Schema-Based Testing requires a [token](../../user-guides/settings/api-tokens.md) for authorizing data exchange between running Patrol's Docker container and Wallarm Cloud. The token can be created in two ways:

* **Automatically** - Schema-Based Testing will create it automatically and include into the `docker run` command on first attempt to copy Docker command from any policy. Other policies will re-use already existing token.
* **Manually** - in Wallarm Console, go to **Settings** → **API Tokens**, click **New token**; on creation, set **Token usage** to `Schema-Based Testing agent`. All policies will use this token.

## Configure test policies

You can configure test policy [based](overview.md#test-basis) on OpenAPI specification (OAS) or Postman collection.

### OAS-based

OpenAPI specification (OAS)-based test policy defines persistently:

* Application's **OpenAPI specification**
* Tests to run

Besides persistent parameters that are the same for any test run, each test policy may optionally include parameters that can be re-defined during each next test run (**Runtime parameters**). Re-defining the runtime parameters can be useful for embedding of Docker into the CI/CD pipelines:

* Application's **Target URL**

    (although can be redefined during each run, some initial value is required)

* Authentication parameters

To configure test policy:

1. Go to Wallarm Console → **Security Testing** → **Schema-Based** → **Test policies**.
1. Click **Add policy**, attach OpenApi specification file.
1. Select [test types](overview.md#test-types) to run.
1. Set **Target URL** (can be re-defined dynamically during each test run).
1. Optionally, add authentication **Runtime parameters**.

    ![Schema-Based Testing - creating test policy based on OpenAPI specification](../../images/vulnerability-detection/apitp-policy-create.png)

### Postman collection-based

With Postman-based security testing you can automate security scans alongside your regular API tests, ensuring that each API run is thoroughly tested for vulnerabilities.

!!! info "API functional tests as basis"
    API Test Patrol utilizes your functional tests to inform the security tests it runs. The broader and more comprehensive your functional tests, the more security coverage API Test Patrol will provide. More APIs, users, and requests mean richer security testing.

Before using Postman data for security testing with API Test Patrol, ensure that you collection and environment files contain:

* functional tests for API endpoints
* location of the target application
* all environment variables set
* necessary credentials to authenticate in the target application

In Wallarm, Postman collection-based test policy defines persistently:

* Application's **Postman collection**.
* **Postman environment file(s)** (optional if all configuration is stored in the main collection file).
* Test case selection is not currently supported for security testing based on Postman collections.

Besides persistent parameters that are the same for any test run, each test policy may optionally include parameters that can be re-defined during each next test run (**Runtime parameters**). Re-defining the runtime parameters can be useful for embedding of Docker into the CI/CD pipelines:

* Application's **Target URL** (defined in the Postman collection or environment files).

    (although can be redefined during each run, some initial value is required)

* Authentication parameters (defined in the Postman collection or environment files).

To configure test policy:

1. Go to Wallarm Console → **Security Testing** → **Schema-Based** → **Test policies**.
1. Click **Add policy**, set **Source** to **Postman collection**.
1. Attach Postman collection file.
1. Optionally, attach Postman environment file(s). Attaching 2 files allows running testing twice with different variable values (for example, different credentials) and then comparing results.

    ![Schema-Based Testing - creating test policy based on Postman collection](../../images/vulnerability-detection/apitp-policy-create-postman.png)

### Editing existing policy

You can edit previously created policies: while clicking policy itself opens its Docker command info, you can click the edit button to access the edit dialog:

![Schema-Based Testing - editing test policy](../../images/vulnerability-detection/sbt-policy-edit.png)

## Docker run

As test policy is [created](#configure-test-policies), it provides you with the Docker run command which allows you start tests for your application:

1. Go to Wallarm Console → **Security Testing** → **Schema-Based** → **Test policies**.
1. Click you policy. The policy's Docker command will be displayed.

    ![Schema-Based Testing - test policy Docker command](../../images/vulnerability-detection/sbt-policy-docker-command.png)

1. Copy command and run it or embed into your CI/CD pipeline. This will run security tests selected in the policy for your application.

    Remember that you can re-define the policy's **Runtime parameters** on each run by adding the corresponding `-e` parameters to the Docker `run` command, for example:

    ```
    -e TARGET_URL="http://dvapi.st.wallarm.tools" 
    -e AUTH_HEADER="Authorization: Bearer <VALUE>"
    ```
    
1. View run statistics and [test run results](explore.md) on the **Test runs** tab.

## Deleting policies

You can delete a test policy. If you do so:

* Information on previous test runs will remain untouched
* You will not be able to run Docker's command based on the deleted policy
* If policy's Docker containers are running, they will continue to do so
* When policy's Docker containers stop, you will not be able to re-run them
